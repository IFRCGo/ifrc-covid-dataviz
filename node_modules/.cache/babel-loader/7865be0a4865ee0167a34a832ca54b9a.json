{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection')) : typeof define === 'function' && define.amd ? define(['exports', 'd3-selection'], factory) : factory(global.d3 = global.d3 || {}, global.d3);\n})(this, function (exports, d3Selection) {\n  'use strict';\n\n  var method;\n  var verify_bounds;\n  var resolve_bounds;\n  var resolve_padding;\n  var pad;\n  var dimensions;\n  var wrap;\n  var textwrap; // test for foreignObject support and determine wrapping strategy\n\n  method = typeof SVGForeignObjectElement === 'undefined' ? 'tspans' : 'foreignobject'; // accept multiple input types as boundaries\n\n  verify_bounds = function (bounds) {\n    var bounds_object, bounds_function;\n    bounds_function = typeof bounds === 'function';\n\n    if (typeof bounds === 'object' && !bounds.nodeType) {\n      if (!bounds.height || !bounds.width) {\n        console.error('text wrapping bounds must specify height and width');\n        return false;\n      } else {\n        return true;\n      }\n    } // convert a selection to bounds\n\n\n    if (bounds instanceof d3Selection.selection || bounds.nodeType || bounds_function || bounds_object) {\n      return true; // use input as bounds directly\n    } else {\n      console.error('invalid bounds specified for text wrapping');\n      return false;\n    }\n  };\n\n  resolve_bounds = function (bounds) {\n    var properties, dimensions, result, i;\n    properties = ['height', 'width'];\n\n    if (typeof bounds === 'function') {\n      dimensions = bounds();\n    } else if (bounds.nodeType) {\n      dimensions = bounds.getBoundingClientRect();\n    } else if (typeof bounds === 'object') {\n      dimensions = bounds;\n    }\n\n    result = Object.create(null);\n\n    for (i = 0; i < properties.length; i++) {\n      result[properties[i]] = dimensions[properties[i]];\n    }\n\n    return result;\n  };\n\n  resolve_padding = function (padding) {\n    var result;\n\n    if (typeof padding === 'function') {\n      result = padding();\n    } else if (typeof padding === 'number') {\n      result = padding;\n    } else if (typeof padding === 'undefined') {\n      result = 0;\n    }\n\n    if (typeof result !== 'number') {\n      console.error('padding could not be converted into a number');\n    } else {\n      return result;\n    }\n  };\n\n  pad = function (dimensions, padding) {\n    var padded;\n    padded = {\n      height: dimensions.height - padding * 2,\n      width: dimensions.width - padding * 2\n    };\n    return padded;\n  };\n\n  dimensions = function (bounds, padding) {\n    var padded;\n    padded = pad(resolve_bounds(bounds), resolve_padding(padding));\n    return padded;\n  };\n\n  wrap = {}; // wrap text using foreignobject html\n\n  wrap.foreignobject = function (text, dimensions, padding) {\n    var content, parent, foreignobject, div; // extract our desired content from the single text element\n\n    content = text.text(); // remove the text node and replace with a foreign object\n\n    parent = d3Selection.select(text.node().parentNode);\n    text.remove();\n    foreignobject = parent.append('foreignObject'); // add foreign object and set dimensions, position, etc\n\n    foreignobject.attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility').attr('width', dimensions.width).attr('height', dimensions.height);\n\n    if (typeof padding === 'number') {\n      foreignobject.attr('x', +text.attr('x') + padding).attr('y', +text.attr('y') + padding);\n    } // insert an HTML div\n\n\n    div = foreignobject.append('xhtml:div'); // set div to same dimensions as foreign object\n\n    div.style('height', dimensions.height).style('width', dimensions.width) // insert text content\n    .html(content);\n    return div;\n  }; // wrap text using tspans\n\n\n  wrap.tspans = function (text, dimensions, padding) {\n    var pieces, piece, line_width, x_offset, tspan, previous_content;\n    pieces = text.text().split(' ').reverse();\n    text.text('');\n    tspan = text.append('tspan');\n    tspan.attr('dx', 0).attr('dy', 0);\n    x_offset = 0;\n\n    while (pieces.length > 0) {\n      piece = pieces.pop();\n      tspan.text(tspan.text() + ' ' + piece);\n      line_width = tspan.node().getComputedTextLength() || 0;\n\n      if (line_width > dimensions.width) {\n        previous_content = tspan.text().split(' ').slice(0, -1).join(' ');\n        tspan.text(previous_content);\n        x_offset = tspan.node().getComputedTextLength() * -1;\n        tspan = text.append('tspan');\n        tspan.attr('dx', x_offset).attr('dy', '1em').text(piece);\n      }\n    }\n\n    if (typeof padding === 'number') {\n      text.attr('y', +text.attr('y') + padding).attr('x', +text.attr('x') + padding);\n    }\n  }; // factory to generate text wrap functions\n\n\n  textwrap = function () {\n    // text wrap function instance\n    var wrapper, bounds, padding;\n\n    wrapper = function (targets) {\n      targets.each(function () {\n        d3Selection.select(this).call(wrap[method], dimensions(bounds, padding), resolve_padding(padding));\n      });\n    }; // get or set wrapping boundaries\n\n\n    wrapper.bounds = function (new_bounds) {\n      if (new_bounds) {\n        if (verify_bounds(new_bounds)) {\n          bounds = new_bounds;\n          return wrapper;\n        } else {\n          console.error('invalid text wrapping bounds');\n          return false;\n        }\n      } else {\n        return bounds;\n      }\n    }; // get or set padding applied on top of boundaries\n\n\n    wrapper.padding = function (new_padding) {\n      if (new_padding) {\n        if (typeof new_padding === 'number' || typeof new_padding === 'function') {\n          padding = new_padding;\n          return wrapper;\n        } else {\n          console.error('text wrap padding value must be either a number or a function');\n          return false;\n        }\n      } else {\n        return padding;\n      }\n    }; // get or set wrapping method\n\n\n    wrapper.method = function (new_method) {\n      if (new_method) {\n        method = new_method;\n        return wrapper;\n      } else {\n        return method;\n      }\n    };\n\n    return wrapper;\n  };\n\n  var textwrap$1 = textwrap;\n  exports.selection = d3Selection.selection;\n  exports.select = d3Selection.select;\n  exports.textwrap = textwrap$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/matthewsmawfield/www/ifrc-covid-dataviz/node_modules/d3-textwrap/build/d3-textwrap.js"],"names":["global","factory","exports","module","require","define","amd","d3","d3Selection","method","verify_bounds","resolve_bounds","resolve_padding","pad","dimensions","wrap","textwrap","SVGForeignObjectElement","bounds","bounds_object","bounds_function","nodeType","height","width","console","error","selection","properties","result","i","getBoundingClientRect","Object","create","length","padding","padded","foreignobject","text","content","parent","div","select","node","parentNode","remove","append","attr","style","html","tspans","pieces","piece","line_width","x_offset","tspan","previous_content","split","reverse","pop","getComputedTextLength","slice","join","wrapper","targets","each","call","new_bounds","new_padding","new_method","textwrap$1","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'd3-selection'], factory) :\n    (factory((global.d3 = global.d3 || {}),global.d3));\n}(this, function (exports,d3Selection) { 'use strict';\n\n    var method;\n    var verify_bounds;\n    var resolve_bounds;\n    var resolve_padding;\n    var pad;\n    var dimensions;\n    var wrap;\n    var textwrap;\n    // test for foreignObject support and determine wrapping strategy\n    method = typeof SVGForeignObjectElement === 'undefined' ? 'tspans' : 'foreignobject';\n\n    // accept multiple input types as boundaries\n    verify_bounds = function(bounds) {\n        var bounds_object,\n            bounds_function;\n        bounds_function = typeof bounds === 'function';\n        if (typeof bounds === 'object' && ! bounds.nodeType) {\n            if (! bounds.height || ! bounds.width) {\n                console.error('text wrapping bounds must specify height and width');\n                return false;\n            } else {\n                return true;\n            }\n        }\n        // convert a selection to bounds\n        if (\n            bounds instanceof d3Selection.selection ||\n            bounds.nodeType ||\n            bounds_function ||\n            bounds_object\n        ) {\n            return true;\n        // use input as bounds directly\n        } else {\n            console.error('invalid bounds specified for text wrapping');\n            return false;\n        }\n    };\n\n    resolve_bounds = function(bounds) {\n        var properties,\n            dimensions,\n            result,\n            i;\n        properties = ['height', 'width'];\n        if (typeof bounds === 'function') {\n            dimensions = bounds();\n        } else if (bounds.nodeType) {\n            dimensions = bounds.getBoundingClientRect();\n        } else if (typeof bounds === 'object') {\n            dimensions = bounds;\n        }\n        result = Object.create(null);\n        for (i = 0; i < properties.length; i++) {\n            result[properties[i]] = dimensions[properties[i]];\n        }\n        return result;\n    };\n\n    resolve_padding = function(padding) {\n        var result;\n        if (typeof padding === 'function') {\n            result = padding();\n        } else if (typeof padding === 'number') {\n            result = padding;\n        } else if (typeof padding === 'undefined') {\n            result = 0;\n        }\n        if (typeof result !== 'number') {\n            console.error('padding could not be converted into a number');\n        } else {\n            return result;\n        }\n    };\n\n    pad = function(dimensions, padding) {\n        var padded;\n        padded = {\n            height: dimensions.height - padding * 2,\n            width: dimensions.width - padding * 2\n        };\n        return padded;\n    };\n\n    dimensions = function(bounds, padding) {\n        var padded;\n        padded = pad(resolve_bounds(bounds), resolve_padding(padding));\n        return padded;\n    };\n\n\n    wrap = {};\n\n    // wrap text using foreignobject html\n    wrap.foreignobject = function(text, dimensions, padding) {\n        var content,\n            parent,\n            foreignobject,\n            div;\n        // extract our desired content from the single text element\n        content = text.text();\n        // remove the text node and replace with a foreign object\n        parent = d3Selection.select(text.node().parentNode);\n        text.remove();\n        foreignobject = parent.append('foreignObject');\n        // add foreign object and set dimensions, position, etc\n        foreignobject\n            .attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility')\n            .attr('width', dimensions.width)\n            .attr('height', dimensions.height);\n        if (typeof padding === 'number') {\n            foreignobject\n                .attr('x', +text.attr('x') + padding)\n                .attr('y', +text.attr('y') + padding);\n        }\n        // insert an HTML div\n        div = foreignobject\n            .append('xhtml:div');\n        // set div to same dimensions as foreign object\n        div\n            .style('height', dimensions.height)\n            .style('width', dimensions.width)\n            // insert text content\n            .html(content);\n        return div;\n    };\n\n    // wrap text using tspans\n    wrap.tspans = function(text, dimensions, padding) {\n        var pieces,\n            piece,\n            line_width,\n            x_offset,\n            tspan,\n            previous_content;\n        pieces = text.text().split(' ').reverse();\n        text.text('');\n        tspan = text.append('tspan');\n        tspan\n            .attr('dx', 0)\n            .attr('dy', 0);\n        x_offset = 0;\n        while (pieces.length > 0) {\n            piece = pieces.pop();\n            tspan.text(tspan.text() + ' ' + piece);\n            line_width = tspan.node().getComputedTextLength() || 0;\n            if (line_width > dimensions.width) {\n                previous_content = tspan.text()\n                    .split(' ')\n                    .slice(0, -1)\n                    .join(' ');\n                tspan.text(previous_content);\n                x_offset = tspan.node().getComputedTextLength() * -1;\n                tspan = text.append('tspan');\n                tspan\n                    .attr('dx', x_offset)\n                    .attr('dy', '1em')\n                    .text(piece);\n            }\n        }\n        if (typeof padding === 'number') {\n            text\n                .attr('y', +text.attr('y') + padding)\n                .attr('x', +text.attr('x') + padding);\n        }\n    };\n\n    // factory to generate text wrap functions\n    textwrap = function() {\n        // text wrap function instance\n        var wrapper,\n            bounds,\n            padding;\n        wrapper = function(targets) {\n            targets.each(function() {\n                d3Selection.select(this).call(wrap[method], dimensions(bounds, padding), resolve_padding(padding));\n            });\n        };\n        // get or set wrapping boundaries\n        wrapper.bounds = function(new_bounds) {\n            if (new_bounds) {\n                if (verify_bounds(new_bounds)) {\n                    bounds = new_bounds;\n                    return wrapper;\n                } else {\n                    console.error('invalid text wrapping bounds');\n                    return false;\n                }\n            } else {\n                return bounds;\n            }\n        };\n        // get or set padding applied on top of boundaries\n        wrapper.padding = function(new_padding) {\n            if (new_padding) {\n                if (typeof new_padding === 'number' || typeof new_padding === 'function') {\n                    padding = new_padding;\n                    return wrapper;\n                } else {\n                    console.error('text wrap padding value must be either a number or a function');\n                    return false;\n                }\n            } else {\n                return padding;\n            }\n        };\n        // get or set wrapping method\n        wrapper.method = function(new_method) {\n            if (new_method) {\n                method = new_method;\n                return wrapper;\n            } else {\n                return method;\n            }\n        };\n        return wrapper;\n    };\n\n    var textwrap$1 = textwrap;\n\n    exports.selection = d3Selection.selection;\n    exports.select = d3Selection.select;\n    exports.textwrap = textwrap$1;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));"]},"metadata":{},"sourceType":"script"}